/* tslint:disable */
/* eslint-disable */
/**
 * GPT Lambda API
 * GPT Lambda AI API Service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'created_at'?: number;
    /**
     * 
     * @type {ApiKeyProvider}
     * @memberof ApiKey
     */
    'provider'?: ApiKeyProvider;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiKeyProvider = {
    FunctionHub: 'FUNCTION_HUB',
    OpenAi: 'OPEN_AI'
} as const;

export type ApiKeyProvider = typeof ApiKeyProvider[keyof typeof ApiKeyProvider];


/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyRequest
     */
    'key'?: string;
    /**
     * 
     * @type {ApiKeyProvider}
     * @memberof ApiKeyRequest
     */
    'provider'?: ApiKeyProvider;
}


/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ApiKeyResponse
     */
    'keys'?: Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Code
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Code
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'updated_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'created_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'parent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'owner_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'function_slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'version'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Code
     */
    'fields_to_update'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CodeUpdateResult
 */
export interface CodeUpdateResult {
    /**
     * 
     * @type {string}
     * @memberof CodeUpdateResult
     */
    'code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeUpdateResult
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeUpdateResult
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeUpdateResult
     */
    'project_id'?: string;
}
/**
 * 
 * @export
 * @interface ExecRequest
 */
export interface ExecRequest {
    /**
     * 
     * @type {string}
     * @memberof ExecRequest
     */
    'code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecRequest
     */
    'exec_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExecRequest
     */
    'validate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExecRequest
     */
    'deployed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecRequest
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecRequest
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface ExecResultAsync
 */
export interface ExecResultAsync {
    /**
     * 
     * @type {string}
     * @memberof ExecResultAsync
     */
    'code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecResultAsync
     */
    'exec_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExecResultAsync
     */
    'validate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecResultAsync
     */
    'result'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExecResultAsync
     */
    'std_out'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ExecResultAsync
     */
    'std_out_str'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecResultAsync
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface FHFunction
 */
export interface FHFunction {
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'owner_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FHFunction
     */
    'is_owner'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'owner_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'owner_avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FHFunction
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FHFunction
     */
    'created_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof FHFunction
     */
    'updated_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'tags'?: string;
    /**
     * 
     * @type {number}
     * @memberof FHFunction
     */
    'fork_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof FHFunction
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface FHFunctions
 */
export interface FHFunctions {
    /**
     * 
     * @type {string}
     * @memberof FHFunctions
     */
    'project_id'?: string;
    /**
     * 
     * @type {Array<FHFunction>}
     * @memberof FHFunctions
     */
    'functions'?: Array<FHFunction>;
}
/**
 * 
 * @export
 * @interface ForkRequest
 */
export interface ForkRequest {
    /**
     * 
     * @type {string}
     * @memberof ForkRequest
     */
    'parent_code_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForkRequest
     */
    'project_id'?: string;
}
/**
 * 
 * @export
 * @interface GPTMessage
 */
export interface GPTMessage {
    /**
     * 
     * @type {string}
     * @memberof GPTMessage
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof GPTMessage
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof GPTMessage
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GPTMessage
     */
    'error'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PageableRequest
 */
export interface PageableRequest {
    /**
     * 
     * @type {string}
     * @memberof PageableRequest
     */
    'query'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageableRequest
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PageableRequest
     */
    'page_num': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PageableRequest
     */
    'sortBy'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PageableRequest
     */
    'sortDir'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PageableResponse
 */
export interface PageableResponse {
    /**
     * 
     * @type {number}
     * @memberof PageableResponse
     */
    'totalRecords'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableResponse
     */
    'numPages'?: number;
    /**
     * 
     * @type {Array<FHFunction>}
     * @memberof PageableResponse
     */
    'records'?: Array<FHFunction>;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'project_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'created_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'updated_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'num_functions'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    'full'?: boolean;
}
/**
 * 
 * @export
 * @interface ProjectCreateRequest
 */
export interface ProjectCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectCreateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectUpdateRequest
 */
export interface ProjectUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUpdateRequest
     */
    'project_id'?: string;
}
/**
 * 
 * @export
 * @interface Projects
 */
export interface Projects {
    /**
     * 
     * @type {Array<Project>}
     * @memberof Projects
     */
    'projects'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface Spec
 */
export interface Spec {
    /**
     * 
     * @type {string}
     * @memberof Spec
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Spec
     */
    'format'?: string;
}
/**
 * 
 * @export
 * @interface SpecResult
 */
export interface SpecResult {
    /**
     * 
     * @type {string}
     * @memberof SpecResult
     */
    'code_id'?: string;
    /**
     * 
     * @type {Spec}
     * @memberof SpecResult
     */
    'spec'?: Spec;
    /**
     * 
     * @type {string}
     * @memberof SpecResult
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface StatusRequest
 */
export interface StatusRequest {
    /**
     * 
     * @type {string}
     * @memberof StatusRequest
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusRequest
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StatusRequest
     */
    'deployed'?: boolean;
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof StatusResponse
     */
    'is_ready'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TokenUsage
 */
export interface TokenUsage {
    /**
     * 
     * @type {number}
     * @memberof TokenUsage
     */
    'prompt_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenUsage
     */
    'completion_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenUsage
     */
    'total_tokens'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TokenUsage
     */
    'function_call_aggregate'?: boolean;
}
/**
 * 
 * @export
 * @interface UserCompletionRequest
 */
export interface UserCompletionRequest {
    /**
     * 
     * @type {Array<GPTMessage>}
     * @memberof UserCompletionRequest
     */
    'messages': Array<GPTMessage>;
    /**
     * 
     * @type {string}
     * @memberof UserCompletionRequest
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCompletionRequest
     */
    'model'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCompletionRequest
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCompletionRequest
     */
    'temperature'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCompletionRequest
     */
    'function_call'?: string;
}
/**
 * 
 * @export
 * @interface UserCompletionResponse
 */
export interface UserCompletionResponse {
    /**
     * 
     * @type {string}
     * @memberof UserCompletionResponse
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCompletionResponse
     */
    'object'?: string;
    /**
     * 
     * @type {Array<GPTMessage>}
     * @memberof UserCompletionResponse
     */
    'messages'?: Array<GPTMessage>;
    /**
     * 
     * @type {TokenUsage}
     * @memberof UserCompletionResponse
     */
    'usage'?: TokenUsage;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserCompletionResponse
     */
    'error'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UserFeedback
 */
export interface UserFeedback {
    /**
     * 
     * @type {string}
     * @memberof UserFeedback
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFeedback
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFeedback
     */
    'body'?: string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'api_key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfile
     */
    'anonymous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'username'?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof UserProfile
     */
    'roles'?: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_authorized'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'auth_mode'?: string;
    /**
     * 
     * @type {Array<Project>}
     * @memberof UserProfile
     */
    'projects'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'error'?: string;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserProfileResponse
     */
    'profile'?: UserProfile;
}
/**
 * 
 * @export
 * @interface UsernameRequest
 */
export interface UsernameRequest {
    /**
     * 
     * @type {string}
     * @memberof UsernameRequest
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface UsernameResponse
 */
export interface UsernameResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UsernameResponse
     */
    'is_available'?: boolean;
}

/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {string} functionSlug 
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devGptCompletion: async (functionSlug: string, userCompletionRequest: UserCompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'functionSlug' is not null or undefined
            assertParamExists('devGptCompletion', 'functionSlug', functionSlug)
            // verify required parameter 'userCompletionRequest' is not null or undefined
            assertParamExists('devGptCompletion', 'userCompletionRequest', userCompletionRequest)
            const localVarPath = `/completion/{function_slug}`
                .replace(`{${"function_slug"}}`, encodeURIComponent(String(functionSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prodCompletionRequest: async (userCompletionRequest: UserCompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCompletionRequest' is not null or undefined
            assertParamExists('prodCompletionRequest', 'userCompletionRequest', userCompletionRequest)
            const localVarPath = `/completion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {string} functionSlug 
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devGptCompletion(functionSlug: string, userCompletionRequest: UserCompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devGptCompletion(functionSlug, userCompletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.devGptCompletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prodCompletionRequest(userCompletionRequest: UserCompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prodCompletionRequest(userCompletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.prodCompletionRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {string} functionSlug 
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devGptCompletion(functionSlug: string, userCompletionRequest: UserCompletionRequest, options?: any): AxiosPromise<UserCompletionResponse> {
            return localVarFp.devGptCompletion(functionSlug, userCompletionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Call GPT completion endpoint
         * @summary Call GPT completion endpoint
         * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prodCompletionRequest(userCompletionRequest: UserCompletionRequest, options?: any): AxiosPromise<UserCompletionResponse> {
            return localVarFp.prodCompletionRequest(userCompletionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * Call GPT completion endpoint
     * @summary Call GPT completion endpoint
     * @param {string} functionSlug 
     * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public devGptCompletion(functionSlug: string, userCompletionRequest: UserCompletionRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).devGptCompletion(functionSlug, userCompletionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call GPT completion endpoint
     * @summary Call GPT completion endpoint
     * @param {UserCompletionRequest} userCompletionRequest GPT Completion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public prodCompletionRequest(userCompletionRequest: UserCompletionRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).prodCompletionRequest(userCompletionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate seed data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSeedData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all FunctionHub users
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (pageableRequest: PageableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageableRequest' is not null or undefined
            assertParamExists('getAllUsers', 'pageableRequest', pageableRequest)
            const localVarPath = `/fh-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log user HTTP requests
         * @param {{ [key: string]: any; }} requestBody Request log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logHttpRequests: async (requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('logHttpRequests', 'requestBody', requestBody)
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate seed data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSeedData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSeedData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.generateSeedData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all FunctionHub users
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(pageableRequest: PageableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(pageableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log user HTTP requests
         * @param {{ [key: string]: any; }} requestBody Request log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logHttpRequests(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logHttpRequests(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.logHttpRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Generate seed data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSeedData(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.generateSeedData(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all FunctionHub users
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(pageableRequest: PageableRequest, options?: any): AxiosPromise<string> {
            return localVarFp.getAllUsers(pageableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log user HTTP requests
         * @param {{ [key: string]: any; }} requestBody Request log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logHttpRequests(requestBody: { [key: string]: any; }, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.logHttpRequests(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Generate seed data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public generateSeedData(options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).generateSeedData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all FunctionHub users
     * @param {PageableRequest} pageableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getAllUsers(pageableRequest: PageableRequest, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).getAllUsers(pageableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log user HTTP requests
     * @param {{ [key: string]: any; }} requestBody Request log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public logHttpRequests(requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).logHttpRequests(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new function
         * @summary Create a function
         * @param {string} body FHFunction create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFunction: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createFunction', 'body', body)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a project directory
         * @summary Create a project
         * @param {ProjectCreateRequest} projectCreateRequest Project create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectCreateRequest: ProjectCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectCreateRequest' is not null or undefined
            assertParamExists('createProject', 'projectCreateRequest', projectCreateRequest)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a function
         * @summary Delete a function
         * @param {string} body FHFunction delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunction: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteFunction', 'body', body)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a project
         * @summary Delete a project
         * @param {string} body Project delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteProject', 'body', body)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fork user code
         * @param {ForkRequest} forkRequest Fork request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forkCode: async (forkRequest: ForkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forkRequest' is not null or undefined
            assertParamExists('forkCode', 'forkRequest', forkRequest)
            const localVarPath = `/code/fork`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all functions in a project
         * @summary Get all functions in a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFunctions: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAllFunctions', 'projectId', projectId)
            const localVarPath = `/project/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all projects
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all public functions
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicFunctions: async (pageableRequest: PageableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageableRequest' is not null or undefined
            assertParamExists('getAllPublicFunctions', 'pageableRequest', pageableRequest)
            const localVarPath = `/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update function metadata
         * @param {FHFunction} fHFunction FHFunction update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunction: async (fHFunction: FHFunction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fHFunction' is not null or undefined
            assertParamExists('updateFunction', 'fHFunction', fHFunction)
            const localVarPath = `/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fHFunction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates project name
         * @summary Update a project
         * @param {ProjectUpdateRequest} projectUpdateRequest Project update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectUpdateRequest: ProjectUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectUpdateRequest' is not null or undefined
            assertParamExists('updateProject', 'projectUpdateRequest', projectUpdateRequest)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new function
         * @summary Create a function
         * @param {string} body FHFunction create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFunction(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFunction(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.createFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a project directory
         * @summary Create a project
         * @param {ProjectCreateRequest} projectCreateRequest Project create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectCreateRequest: ProjectCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.createProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a function
         * @summary Delete a function
         * @param {string} body FHFunction delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFunction(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FHFunctions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFunction(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.deleteFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a project
         * @summary Delete a project
         * @param {string} body Project delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.deleteProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fork user code
         * @param {ForkRequest} forkRequest Fork request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forkCode(forkRequest: ForkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forkCode(forkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.forkCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all functions in a project
         * @summary Get all functions in a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFunctions(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FHFunctions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFunctions(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.getAllFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all projects
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.getAllProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all public functions
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPublicFunctions(pageableRequest: PageableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPublicFunctions(pageableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.getAllPublicFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update function metadata
         * @param {FHFunction} fHFunction FHFunction update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFunction(fHFunction: FHFunction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FHFunctions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunction(fHFunction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.updateFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates project name
         * @summary Update a project
         * @param {ProjectUpdateRequest} projectUpdateRequest Project update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectUpdateRequest: ProjectUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * Creates a new function
         * @summary Create a function
         * @param {string} body FHFunction create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFunction(body: string, options?: any): AxiosPromise<CodeUpdateResult> {
            return localVarFp.createFunction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a project directory
         * @summary Create a project
         * @param {ProjectCreateRequest} projectCreateRequest Project create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectCreateRequest: ProjectCreateRequest, options?: any): AxiosPromise<Projects> {
            return localVarFp.createProject(projectCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a function
         * @summary Delete a function
         * @param {string} body FHFunction delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunction(body: string, options?: any): AxiosPromise<FHFunctions> {
            return localVarFp.deleteFunction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a project
         * @summary Delete a project
         * @param {string} body Project delete request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(body: string, options?: any): AxiosPromise<Projects> {
            return localVarFp.deleteProject(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fork user code
         * @param {ForkRequest} forkRequest Fork request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forkCode(forkRequest: ForkRequest, options?: any): AxiosPromise<CodeUpdateResult> {
            return localVarFp.forkCode(forkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all functions in a project
         * @summary Get all functions in a project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFunctions(projectId: string, options?: any): AxiosPromise<FHFunctions> {
            return localVarFp.getAllFunctions(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all projects
         * @summary Get all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjects(options?: any): AxiosPromise<Projects> {
            return localVarFp.getAllProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all public functions
         * @param {PageableRequest} pageableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicFunctions(pageableRequest: PageableRequest, options?: any): AxiosPromise<PageableResponse> {
            return localVarFp.getAllPublicFunctions(pageableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update function metadata
         * @param {FHFunction} fHFunction FHFunction update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunction(fHFunction: FHFunction, options?: any): AxiosPromise<FHFunctions> {
            return localVarFp.updateFunction(fHFunction, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates project name
         * @summary Update a project
         * @param {ProjectUpdateRequest} projectUpdateRequest Project update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectUpdateRequest: ProjectUpdateRequest, options?: any): AxiosPromise<Projects> {
            return localVarFp.updateProject(projectUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * Creates a new function
     * @summary Create a function
     * @param {string} body FHFunction create request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createFunction(body: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).createFunction(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a project directory
     * @summary Create a project
     * @param {ProjectCreateRequest} projectCreateRequest Project create request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createProject(projectCreateRequest: ProjectCreateRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).createProject(projectCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a function
     * @summary Delete a function
     * @param {string} body FHFunction delete request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteFunction(body: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).deleteFunction(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a project
     * @summary Delete a project
     * @param {string} body Project delete request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteProject(body: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).deleteProject(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fork user code
     * @param {ForkRequest} forkRequest Fork request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public forkCode(forkRequest: ForkRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).forkCode(forkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all functions in a project
     * @summary Get all functions in a project
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getAllFunctions(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getAllFunctions(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all projects
     * @summary Get all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getAllProjects(options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getAllProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all public functions
     * @param {PageableRequest} pageableRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getAllPublicFunctions(pageableRequest: PageableRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getAllPublicFunctions(pageableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update function metadata
     * @param {FHFunction} fHFunction FHFunction update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateFunction(fHFunction: FHFunction, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).updateFunction(fHFunction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates project name
     * @summary Update a project
     * @param {ProjectUpdateRequest} projectUpdateRequest Project update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateProject(projectUpdateRequest: ProjectUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProjectApiFp(this.configuration).updateProject(projectUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RuntimeApi - axios parameter creator
 * @export
 */
export const RuntimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows user code execution if all validations pass
         * @summary Deploy user code
         * @param {ExecRequest} execRequest Deploy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy: async (execRequest: ExecRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'execRequest' is not null or undefined
            assertParamExists('deploy', 'execRequest', execRequest)
            const localVarPath = `/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(execRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute user code in a secure sandbox
         * @summary Execute user code
         * @param {ExecRequest} execRequest Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exec: async (execRequest: ExecRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'execRequest' is not null or undefined
            assertParamExists('exec', 'execRequest', execRequest)
            const localVarPath = `/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(execRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user code detail
         * @summary Get user code detail
         * @param {string} codeId 
         * @param {boolean} [bySlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeDetail: async (codeId: string, bySlug?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeId' is not null or undefined
            assertParamExists('getCodeDetail', 'codeId', codeId)
            const localVarPath = `/code/{code_id}`
                .replace(`{${"code_id"}}`, encodeURIComponent(String(codeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bySlug !== undefined) {
                localVarQueryParameter['by_slug'] = bySlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execution results are short-lived
         * @summary Get result of completed execution
         * @param {string} execId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecResult: async (execId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'execId' is not null or undefined
            assertParamExists('getExecResult', 'execId', execId)
            const localVarPath = `/e-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (execId !== undefined) {
                localVarQueryParameter['exec_id'] = execId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCode: async (codeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeId' is not null or undefined
            assertParamExists('getUserCode', 'codeId', codeId)
            const localVarPath = `/npm/{code_id}`
                .replace(`{${"code_id"}}`, encodeURIComponent(String(codeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles user code execution result
         * @summary Execution result handler
         * @param {ExecResultAsync} execResultAsync Execution result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExecResult: async (execResultAsync: ExecResultAsync, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'execResultAsync' is not null or undefined
            assertParamExists('handleExecResult', 'execResultAsync', execResultAsync)
            const localVarPath = `/e-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(execResultAsync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles spec generation result
         * @summary Spec result handler
         * @param {SpecResult} specResult Spec result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSpecResult: async (specResult: SpecResult, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specResult' is not null or undefined
            assertParamExists('handleSpecResult', 'specResult', specResult)
            const localVarPath = `/s-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specResult, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runDevFunction: async (functionSlug: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'functionSlug' is not null or undefined
            assertParamExists('runDevFunction', 'functionSlug', functionSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('runDevFunction', 'body', body)
            const localVarPath = `/d/{function_slug}`
                .replace(`{${"function_slug"}}`, encodeURIComponent(String(functionSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProdFunction: async (functionSlug: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'functionSlug' is not null or undefined
            assertParamExists('runProdFunction', 'functionSlug', functionSlug)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('runProdFunction', 'body', body)
            const localVarPath = `/{function_slug}`
                .replace(`{${"function_slug"}}`, encodeURIComponent(String(functionSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update code
         * @summary Update code
         * @param {Code} code Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCode: async (code: Code, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateCode', 'code', code)
            const localVarPath = `/update-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(code, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuntimeApi - functional programming interface
 * @export
 */
export const RuntimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuntimeApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows user code execution if all validations pass
         * @summary Deploy user code
         * @param {ExecRequest} execRequest Deploy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploy(execRequest: ExecRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploy(execRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.deploy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute user code in a secure sandbox
         * @summary Execute user code
         * @param {ExecRequest} execRequest Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exec(execRequest: ExecRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecResultAsync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exec(execRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.exec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user code detail
         * @summary Get user code detail
         * @param {string} codeId 
         * @param {boolean} [bySlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeDetail(codeId: string, bySlug?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Code>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeDetail(codeId, bySlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.getCodeDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execution results are short-lived
         * @summary Get result of completed execution
         * @param {string} execId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecResult(execId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecResultAsync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecResult(execId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.getExecResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCode(codeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCode(codeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.getUserCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles user code execution result
         * @summary Execution result handler
         * @param {ExecResultAsync} execResultAsync Execution result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleExecResult(execResultAsync: ExecResultAsync, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleExecResult(execResultAsync, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.handleExecResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles spec generation result
         * @summary Spec result handler
         * @param {SpecResult} specResult Spec result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleSpecResult(specResult: SpecResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleSpecResult(specResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.handleSpecResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runDevFunction(functionSlug: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runDevFunction(functionSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.runDevFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runProdFunction(functionSlug: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runProdFunction(functionSlug, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.runProdFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update code
         * @summary Update code
         * @param {Code} code Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCode(code: Code, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCode(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RuntimeApi.updateCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RuntimeApi - factory interface
 * @export
 */
export const RuntimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuntimeApiFp(configuration)
    return {
        /**
         * Allows user code execution if all validations pass
         * @summary Deploy user code
         * @param {ExecRequest} execRequest Deploy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploy(execRequest: ExecRequest, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.deploy(execRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute user code in a secure sandbox
         * @summary Execute user code
         * @param {ExecRequest} execRequest Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exec(execRequest: ExecRequest, options?: any): AxiosPromise<ExecResultAsync> {
            return localVarFp.exec(execRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user code detail
         * @summary Get user code detail
         * @param {string} codeId 
         * @param {boolean} [bySlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeDetail(codeId: string, bySlug?: boolean, options?: any): AxiosPromise<Code> {
            return localVarFp.getCodeDetail(codeId, bySlug, options).then((request) => request(axios, basePath));
        },
        /**
         * Execution results are short-lived
         * @summary Get result of completed execution
         * @param {string} execId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecResult(execId: string, options?: any): AxiosPromise<ExecResultAsync> {
            return localVarFp.getExecResult(execId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} codeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCode(codeId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getUserCode(codeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles user code execution result
         * @summary Execution result handler
         * @param {ExecResultAsync} execResultAsync Execution result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExecResult(execResultAsync: ExecResultAsync, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.handleExecResult(execResultAsync, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles spec generation result
         * @summary Spec result handler
         * @param {SpecResult} specResult Spec result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSpecResult(specResult: SpecResult, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.handleSpecResult(specResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runDevFunction(functionSlug: string, body: string, options?: any): AxiosPromise<string> {
            return localVarFp.runDevFunction(functionSlug, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute any user function with dynamically generated request and response payloads
         * @summary Execute any user function
         * @param {string} functionSlug 
         * @param {string} body Execution request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProdFunction(functionSlug: string, body: string, options?: any): AxiosPromise<string> {
            return localVarFp.runProdFunction(functionSlug, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update code
         * @summary Update code
         * @param {Code} code Update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCode(code: Code, options?: any): AxiosPromise<CodeUpdateResult> {
            return localVarFp.updateCode(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RuntimeApi - object-oriented interface
 * @export
 * @class RuntimeApi
 * @extends {BaseAPI}
 */
export class RuntimeApi extends BaseAPI {
    /**
     * Allows user code execution if all validations pass
     * @summary Deploy user code
     * @param {ExecRequest} execRequest Deploy request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public deploy(execRequest: ExecRequest, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).deploy(execRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute user code in a secure sandbox
     * @summary Execute user code
     * @param {ExecRequest} execRequest Execution request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public exec(execRequest: ExecRequest, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).exec(execRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user code detail
     * @summary Get user code detail
     * @param {string} codeId 
     * @param {boolean} [bySlug] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public getCodeDetail(codeId: string, bySlug?: boolean, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).getCodeDetail(codeId, bySlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execution results are short-lived
     * @summary Get result of completed execution
     * @param {string} execId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public getExecResult(execId: string, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).getExecResult(execId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} codeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public getUserCode(codeId: string, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).getUserCode(codeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles user code execution result
     * @summary Execution result handler
     * @param {ExecResultAsync} execResultAsync Execution result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public handleExecResult(execResultAsync: ExecResultAsync, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).handleExecResult(execResultAsync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles spec generation result
     * @summary Spec result handler
     * @param {SpecResult} specResult Spec result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public handleSpecResult(specResult: SpecResult, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).handleSpecResult(specResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute any user function with dynamically generated request and response payloads
     * @summary Execute any user function
     * @param {string} functionSlug 
     * @param {string} body Execution request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public runDevFunction(functionSlug: string, body: string, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).runDevFunction(functionSlug, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute any user function with dynamically generated request and response payloads
     * @summary Execute any user function
     * @param {string} functionSlug 
     * @param {string} body Execution request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public runProdFunction(functionSlug: string, body: string, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).runProdFunction(functionSlug, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update code
     * @summary Update code
     * @param {Code} code Update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeApi
     */
    public updateCode(code: Code, options?: RawAxiosRequestConfig) {
        return RuntimeApiFp(this.configuration).updateCode(code, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpecApi - axios parameter creator
 * @export
 */
export const SpecApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user spec generation status
         * @param {StatusRequest} statusRequest Status request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecStatus: async (statusRequest: StatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusRequest' is not null or undefined
            assertParamExists('getSpecStatus', 'statusRequest', statusRequest)
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} functionSlug 
         * @param {string} version 
         * @param {string} authToken 
         * @param {string} env 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSpec: async (functionSlug: string, version: string, authToken: string, env: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'functionSlug' is not null or undefined
            assertParamExists('getUserSpec', 'functionSlug', functionSlug)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getUserSpec', 'version', version)
            // verify required parameter 'authToken' is not null or undefined
            assertParamExists('getUserSpec', 'authToken', authToken)
            // verify required parameter 'env' is not null or undefined
            assertParamExists('getUserSpec', 'env', env)
            const localVarPath = `/spec/{function_slug}/{version}/{auth_token}/{env}`
                .replace(`{${"function_slug"}}`, encodeURIComponent(String(functionSlug)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"auth_token"}}`, encodeURIComponent(String(authToken)))
                .replace(`{${"env"}}`, encodeURIComponent(String(env)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecApi - functional programming interface
 * @export
 */
export const SpecApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user spec generation status
         * @param {StatusRequest} statusRequest Status request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecStatus(statusRequest: StatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecStatus(statusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecApi.getSpecStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} functionSlug 
         * @param {string} version 
         * @param {string} authToken 
         * @param {string} env 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSpec(functionSlug: string, version: string, authToken: string, env: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSpec(functionSlug, version, authToken, env, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpecApi.getUserSpec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpecApi - factory interface
 * @export
 */
export const SpecApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecApiFp(configuration)
    return {
        /**
         * Get user spec generation status
         * @param {StatusRequest} statusRequest Status request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecStatus(statusRequest: StatusRequest, options?: any): AxiosPromise<StatusResponse> {
            return localVarFp.getSpecStatus(statusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} functionSlug 
         * @param {string} version 
         * @param {string} authToken 
         * @param {string} env 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSpec(functionSlug: string, version: string, authToken: string, env: string, options?: any): AxiosPromise<string> {
            return localVarFp.getUserSpec(functionSlug, version, authToken, env, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecApi - object-oriented interface
 * @export
 * @class SpecApi
 * @extends {BaseAPI}
 */
export class SpecApi extends BaseAPI {
    /**
     * Get user spec generation status
     * @param {StatusRequest} statusRequest Status request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecApi
     */
    public getSpecStatus(statusRequest: StatusRequest, options?: RawAxiosRequestConfig) {
        return SpecApiFp(this.configuration).getSpecStatus(statusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} functionSlug 
     * @param {string} version 
     * @param {string} authToken 
     * @param {string} env 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecApi
     */
    public getUserSpec(functionSlug: string, version: string, authToken: string, env: string, options?: RawAxiosRequestConfig) {
        return SpecApiFp(this.configuration).getUserSpec(functionSlug, version, authToken, env, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create user feedback
         * @param {UserFeedback} userFeedback Feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFeedback: async (userFeedback: UserFeedback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFeedback' is not null or undefined
            assertParamExists('createUserFeedback', 'userFeedback', userFeedback)
            const localVarPath = `/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userFeedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an api key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (apiKeyRequest: ApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            assertParamExists('deleteKey', 'apiKeyRequest', apiKeyRequest)
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all env variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvVariables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/env-variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user profile or create one if it doesn\'t exist
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserprofile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update username
         * @param {UsernameRequest} usernameRequest Username request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsername: async (usernameRequest: UsernameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernameRequest' is not null or undefined
            assertParamExists('updateUsername', 'usernameRequest', usernameRequest)
            const localVarPath = `/username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usernameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an api key or insert a vendor key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertApiKey: async (apiKeyRequest: ApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyRequest' is not null or undefined
            assertParamExists('upsertApiKey', 'apiKeyRequest', apiKeyRequest)
            const localVarPath = `/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upsert user env variables
         * @param {string} body Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEnvVariables: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('upsertEnvVariables', 'body', body)
            const localVarPath = `/env-variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if username exists
         * @param {UsernameRequest} usernameRequest Username check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameExists: async (usernameRequest: UsernameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernameRequest' is not null or undefined
            assertParamExists('usernameExists', 'usernameRequest', usernameRequest)
            const localVarPath = `/username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usernameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create user feedback
         * @param {UserFeedback} userFeedback Feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFeedback(userFeedback: UserFeedback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFeedback(userFeedback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an api key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(apiKeyRequest: ApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(apiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getApiKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all env variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvVariables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvVariables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getEnvVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user profile or create one if it doesn\'t exist
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserprofile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserprofile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserprofile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update username
         * @param {UsernameRequest} usernameRequest Username request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsername(usernameRequest: UsernameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsername(usernameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate an api key or insert a vendor key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertApiKey(apiKeyRequest: ApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertApiKey(apiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.upsertApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upsert user env variables
         * @param {string} body Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertEnvVariables(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertEnvVariables(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.upsertEnvVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if username exists
         * @param {UsernameRequest} usernameRequest Username check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usernameExists(usernameRequest: UsernameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsernameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usernameExists(usernameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usernameExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Create user feedback
         * @param {UserFeedback} userFeedback Feedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFeedback(userFeedback: UserFeedback, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.createUserFeedback(userFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an api key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(apiKeyRequest: ApiKeyRequest, options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.deleteKey(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.getApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all env variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvVariables(options?: any): AxiosPromise<string> {
            return localVarFp.getEnvVariables(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user profile or create one if it doesn\'t exist
         * @summary Get user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserprofile(options?: any): AxiosPromise<UserProfileResponse> {
            return localVarFp.getUserprofile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update username
         * @param {UsernameRequest} usernameRequest Username request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsername(usernameRequest: UsernameRequest, options?: any): AxiosPromise<UserProfileResponse> {
            return localVarFp.updateUsername(usernameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an api key or insert a vendor key
         * @param {ApiKeyRequest} apiKeyRequest Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertApiKey(apiKeyRequest: ApiKeyRequest, options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.upsertApiKey(apiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upsert user env variables
         * @param {string} body Api key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEnvVariables(body: string, options?: any): AxiosPromise<string> {
            return localVarFp.upsertEnvVariables(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if username exists
         * @param {UsernameRequest} usernameRequest Username check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameExists(usernameRequest: UsernameRequest, options?: any): AxiosPromise<UsernameResponse> {
            return localVarFp.usernameExists(usernameRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Create user feedback
     * @param {UserFeedback} userFeedback Feedback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserFeedback(userFeedback: UserFeedback, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserFeedback(userFeedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an api key
     * @param {ApiKeyRequest} apiKeyRequest Api key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteKey(apiKeyRequest: ApiKeyRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteKey(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getApiKeys(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all env variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getEnvVariables(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getEnvVariables(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user profile or create one if it doesn\'t exist
     * @summary Get user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserprofile(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserprofile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update username
     * @param {UsernameRequest} usernameRequest Username request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUsername(usernameRequest: UsernameRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUsername(usernameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an api key or insert a vendor key
     * @param {ApiKeyRequest} apiKeyRequest Api key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public upsertApiKey(apiKeyRequest: ApiKeyRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).upsertApiKey(apiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upsert user env variables
     * @param {string} body Api key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public upsertEnvVariables(body: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).upsertEnvVariables(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if username exists
     * @param {UsernameRequest} usernameRequest Username check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usernameExists(usernameRequest: UsernameRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usernameExists(usernameRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



